

# 项目1

[TOC]

### 一. 数据库设计

#### 1. 表结构设计 (重点)

- `json`类型  保存封面图片
  - 对于没有反向查询需求, 且数据结构简单的对多关系数据, 可以直接使用一个字段保存起来, 不需要分表

```json
{
"count": 3,
"covers": ['http://xxx', '', '']
}
```

![image-20190612214236026](项目1.assets/image-20190612214236026.png)

#### 2. 类型设计 (重点)

- 数字
  - bigint
    - 8个字节
    - `bigint unsigned`   正数最大利用率
    - 主键
  - tinyint
    - 1个字节  0-255  2^8
    - 类型/状态/bool
  - int/float
    - 4个字节
  - bigint(5)
    - 只是显示长度, 不额外占用空间
  
- 字符
  - varchar
    - 0-255个字节
    - 空间可变, 效率低(需要计算偏移)
    - 用户名
  - `char`
    - 0-255个字节
    - 空间固定, 查询效率高
    - 手机号
  - text
    - 0-64KB
    - 长文本
    - 评论内容
  - long text
    - 0-4GB
    - 极长文本
    - 文章内容
  - blob
    - 0-64KB
    - 二进制形式长文本
    - 相比text, 没有字符集和排序功能
    - 二进制数据一般使用单独的存储系统, 使用率低
  
- 日期/时间

  - datetime
    - 8个字节
    - 范围   [1001年, 9999年]
    - 不受时区影响
  - timestamp
    - 4个字节
    - 范围 [1970年, 2038年]
    - 受时区影响
    - 效率更高

- 选择原则

  - 数据类型越小, 读写越快, 占用磁盘/内存/CPU缓存越小
  - 数据类型越简单, 读写越快       数字比字符更简单(需要编解码, 且排序复杂)

  

#### 3. 约束设计 (重点)

```sql
create table t_user(
  id bigint not null auto_increment,  # 非空约束
  mobile char(11),
  leaderid bigint,
  type tinyint default 0,  # 默认值约束
  unique (mobile),  # 唯一约束
  primary key (id),  # 主键约束
  # foreign key (leaderid) references t_user(id)  # 外键约束
)
```

- NOT NULL
  
  - 主键
  
- DEFAULT

  - 状态/类型
  - 日期/时间

- `字段尽量不用NULL`
- 可空列会占用更多空间(多一个字节记录是否为null), 并且需要内部的额外处理
  - 易出错
    - count(字段1)统计时, 字段1为NULL的记录不会被统计  
    - timestamp类型
    - not in / != 语句, 查询时不会被统计
  - 索引不存储null值, 查询时不会被统计
  
- UNIQUE

  - 昵称, 手机号

- 主键约束

  - NOT  NULL + UNIQUE

- `外键约束`
- 无论哪种方案, 都不影响查询, 但都影响更新&删除效率
  
- `不建立外键约束`(物理外键), 只定义普通的字段记录主键(逻辑外键)
    - 仍然可以多表联查
    - 删除/更新效率高 
    - 有出错的风险, 由程序逻辑来控制




#### 4. 索引设计

- 为了提高查询速度提供的一种数据结构, 类似书的目录, 方便快速查询出数据, 而不是从头到尾的依次比对
- 优点
  - 增加查询速度
- 缺点
  - 增加数据库的存储空间
  - 减慢增删改速度(索引需要随之改变)
- 创建索引

```sql
create table t_user(
  id int not null,  
  mobile char(10) not null,
  key (mobile)  # 设置索引
) 

alter table t_user add nickname varchar(20);
alter table t_user add key (nickname);
```

- 查看索引

  ```sql
  show keys from t_user;
  ```

- 查看查询是否使用了索引

```sql
explain select * from t_user where nickname = 'zs';
```

- 索引分类

  - 普通索引 index
    - 不要用可空列作为索引, 易出错
    - 适合的字段
      - 数据量超过300的表应该有索引；
      - 经常与其他表进行连接的表，在连接字段上应该建立索引；
      - 经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
      - 索引应该建在选择性高(范围广)的字段上；
      - 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引(索引类似英文字典, 越短的单词越好找)；
      - 频繁进行数据操作的表，不要建立太多的索引；
    - 场景
      - `自定义的外键字段`(逻辑外键)
      - `适用于改动小, 查询多的场景` 如公司内部的员工系统
  - 联合索引
    - 联合索引必须符合`最左原则`, 否则无效
      - where mobile /where mobile and type会使用索引
      - where type 不会使用索引

  ```sql
  create table t_user(
    id int not null,  # 非空约束
    mobile char(10) not null,
    type tinyint default 0,
    key k_mobile_type (mobile, type)  # 设置联合索引
  )
  ```

  - 主键索引 创建主键后自动生成
  - 唯一索引 设置唯一约束后自动生成
  - 外键索引 设置外键约束后自动生成

- 索引原理

  - Mysql的索引存储结构为B+tree结构 平衡二叉树

![image-20190613021629982](项目1.assets/image-20190613021629982.png)

![image-20190613021654054](项目1.assets/image-20190613021654054.png)

- 聚簇索引(聚集索引): 主键B+树在叶子节点直接存储的是数据行, InnoDB引擎使用

![image-20190613021715255](项目1.assets/image-20190613021715255.png)

- 非聚簇索引: 主键B+树在叶子节点只是存储真正数据行的地址, 数据行和索引存储在不同的结构中, MyISAM引擎使用

![image-20190613021741122](项目1.assets/image-20190613021741122.png)

#### 5. 主键设计

- InnoDB的主键为什么选择自增
  
  - 数据和主键索引是绑定在一起的, 主键自增就会让数据顺序添加到B+Tree中, 写完一页再写下一页, 不需要为了索引的排列而移动数据和页分裂(会导致插入速度变慢), 并且移动和页分裂也会降低查询速度
- 能不能使用业务字段作为主键(业务主键)
  - 可以, 但不好
  - 使用自增主键性能会快很多
  - 业务字段更新频繁 , 一旦修改, 索引也要跟着变, 成本较高 比如使用手机号作为外键, 一旦用户修改手机号, 则外键也需要同步修改
  - 所以一般采用和业务无关的数据充当主键(逻辑主键)
- 复合/联合主键
  - 将多个业务键联合定义为主键
  - 优点
    - 节省空间
  - 缺点
    - 和业务有关, 频繁改动
    - 不是自增, 性能差
  - 尽量不要用
  
  

#### 6. 三范式和反范式设计 (重点)

- 规则
  - 第一范式: 字段具有原子性, 不可拆分
  - 第二范式: 依赖于全部主键, 而非部分主键
    - 主要针对复合主键,一般都会遵守
    - 比如某人的成绩 由班级+姓名决定, 成绩完全依赖于班级+姓名, 但是班主任姓名只依赖于班级, 不依赖学生姓名, 则不能在该表中
  - 第三范式: 只依赖于主键, 非主键字段互不依赖
- 目的
  - 减少冗余字段/重复的数据

------

- 回复数/评论数/点赞数 都可以通过聚合查询来获取  `select count(*) from t_comment group by news_id`

- 如果单独定义字段来记录, 该字段就称为冗余字段

- 这种设计称为 反范式设计

  - 通过加入冗余字段/重复数据 来提高数据库的查询速度
  - 减少关联查询
  - 用空间换取时间

- 范式是武功招式, 如何运用全看自己

  
### 二. flask-sqlalchemy基础

#### 1. 配置和连接

- ORM优点
  - 自己写要保证sql语法的正确性
  - orm可以支持多种数据库的语法, 减少学习成本
  - 防止sql注入攻击
- sqlalchemy    python中的最强大的ORM框架
- flask-sqlalchemy    flask组件, 让flask可以接入sqlalchemy
- 安装 `pip install flask-sqlalchemy`

![image-20190707084922661](项目1.assets/image-20190707084922661.png)

![image-20190730171152900](项目1.assets/image-20190730171152900.png)

- ModuleNotFoundError: No module named 'MySQLdb'   `pip install mysqlclient`



#### 2. 增加数据 (重点)

![image-20190730172631733](项目1.assets/image-20190730172631733.png)



#### 3. 查询数据 (重点)

- 交互模式
  - 推荐使用ipython, 会自动将虚拟环境的包路径导入并优先查询   `pip install ipython`

![image-20190730174630904](项目1.assets/image-20190730174630904.png)


